import type { CancelablePromise } from '../core/CancelablePromise';
import type { BaseHttpRequest } from '../core/BaseHttpRequest';
export declare class RequestorControlService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Creates new Activity based on given Agreement.
     * **Note:** This call shall get routed as a provider event (see ProviderEvent structure).
     * @param requestBody
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any Success
     * @throws ApiError
     */
    createActivity(requestBody: (string | {
        agreementId: string;
        requestorPubKey?: string;
    }), timeout?: number): CancelablePromise<(string | {
        activityId: string;
        credentials?: {
            sgx: {
                enclavePubKey: string;
                requestorPubKey: string;
                payloadHash: string;
                iasReport: string;
                iasSig: string;
            };
        };
    })>;
    /**
     * Executes an ExeScript batch within a given Activity.
     * **Note:** This call shall get routed directly to ExeUnit.
     * @param activityId
     * @param requestBody
     * @returns string Success
     * @throws ApiError
     */
    exec(activityId: string, requestBody: {
        text: string;
    }): CancelablePromise<string>;
    /**
     * Sends encrypted command to secure exe-unit.
     * @param activityId
     * @param requestBody
     * @returns binary Success
     * @throws ApiError
     */
    callEncrypted(activityId: string, requestBody: Blob): CancelablePromise<Blob>;
    /**
     * Queries for ExeScript batch results.
     * 'This call shall collect ExeScriptCommand result objects received directly from ExeUnit (via the long polling pattern). **Note:** two formats of response are specified (as indicated by the Accept header):
     * - application/json - standard JSON response, specified below, as code generators handle it properly.
     * - text/event-stream - an EventSource implementation (as per https://www.w3.org/TR/eventsource/).
     * This isn't explicitly specified as code generators generally are unable to handle this.
     * The streaming events adhere to following format:
     *
     * event: runtime
     * data: <RuntimeEvent structure>
     *
     * This streaming endpoint requires dedicated implementation. '
     *
     * @param activityId
     * @param batchId
     * @param commandIndex Wait until command with the specified index finishes. Must be accompanied by a valid "pollTimeout" query parameter.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @returns any Success
     * @throws ApiError
     */
    getExecBatchResults(activityId: string, batchId: string, commandIndex?: number, timeout?: number): CancelablePromise<Array<{
        index: number;
        eventDate: string;
        result: 'Ok' | 'Error';
        stdout?: string;
        stderr?: string;
        message?: string;
        isBatchFinished?: boolean;
    }>>;
    /**
     * Destroys given Activity.
     * **Note:** This call shall get routed as a provider event (see ProviderEvent structure).
     * @param activityId
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any Success
     * @throws ApiError
     */
    destroyActivity(activityId: string, timeout?: number): CancelablePromise<any>;
}
