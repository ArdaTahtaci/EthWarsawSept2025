import type { CancelablePromise } from '../core/CancelablePromise';
import type { BaseHttpRequest } from '../core/BaseHttpRequest';
export declare class ProviderService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Returns agreement_id corresponding to the activity
     * 'This call shall return id of the agreement that lead to the creation of this activity'
     *
     * @param activityId
     * @returns string Agreement.
     * @throws ApiError
     */
    getActivityAgreement(activityId: string): CancelablePromise<string>;
    /**
     * Fetch Requestor command events.
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    collectActivityEvents(appSessionId?: string, afterTimestamp?: string, timeout?: number, maxEvents?: number): CancelablePromise<Array<{
        eventType: string;
        eventDate: string;
        activityId: string;
        agreementId: string;
    }>>;
    /**
     * Get state of specified Activity.
     * @param activityId
     * @returns any Success
     * @throws ApiError
     */
    getActivityState(activityId: string): CancelablePromise<{
        /**
         * State pair tuple (CurrentState, NextState). NextState is equal to null if there is no pending transition between states.
         */
        state: Array<'New' | 'Initialized' | 'Deployed' | 'Ready' | 'Unresponsive' | 'Terminated' | null>;
        /**
         * Reason for Activity termination (specified when Activity in Terminated state).
         */
        reason?: string;
        /**
         * If error caused state change - error message shall be provided.
         */
        errorMessage?: string;
    }>;
    /**
     * Set state of specified Activity.
     * @param activityId
     * @param requestBody
     * @returns any Success
     * @throws ApiError
     */
    setActivityState(activityId: string, requestBody: {
        /**
         * State pair tuple (CurrentState, NextState). NextState is equal to null if there is no pending transition between states.
         */
        state: Array<'New' | 'Initialized' | 'Deployed' | 'Ready' | 'Unresponsive' | 'Terminated' | null>;
        /**
         * Reason for Activity termination (specified when Activity in Terminated state).
         */
        reason?: string;
        /**
         * If error caused state change - error message shall be provided.
         */
        errorMessage?: string;
    }): CancelablePromise<any>;
    /**
     * Get usage of specified Activity.
     * @param activityId
     * @returns any Success
     * @throws ApiError
     */
    getActivityUsage(activityId: string): CancelablePromise<{
        /**
         * Current vector of usage counters consumed by the Activity. The sequence of values corresponds to Usage Vector property (golem.usage.vector) as indicated in the Agreement (Offer part).
         */
        currentUsage?: Array<number>;
        /**
         * Usage update timestamp (UTC)
         */
        timestamp: number;
    }>;
}
