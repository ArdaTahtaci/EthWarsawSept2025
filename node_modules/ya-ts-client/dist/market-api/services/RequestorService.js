"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestorService = void 0;
class RequestorService {
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * Creates new offer/demand Iterator.
     *
     * @param requestBody
     * @returns any Unexpected error.
     * @returns string Market scan start.
     * @throws ApiError
     */
    beginScan(requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/scan',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
            },
        });
    }
    /**
     * @param subscriptionId
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param peerId allows to query offers from specified node.
     *
     * @returns any Scan Events
     * @throws ApiError
     */
    collectScanResults(subscriptionId, timeout = 5, maxEvents = 10, peerId) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/scan/{subscriptionId}/events',
            path: {
                'subscriptionId': subscriptionId,
            },
            query: {
                'timeout': timeout,
                'maxEvents': maxEvents,
                'peerId': peerId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
    /**
     * @param subscriptionId
     * @returns any Unexpected error.
     * @throws ApiError
     */
    endScan(subscriptionId) {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/scan/{subscriptionId}',
            path: {
                'subscriptionId': subscriptionId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
    /**
     * GetDemands - Fetches all active Demands which have been published by the Requestor.
     * @returns any Demand list.
     * @throws ApiError
     */
    getDemands() {
        return this.httpRequest.request({
            method: 'GET',
            url: '/demands',
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
            },
        });
    }
    /**
     * SubscribeDemand - Publishes Requestor capabilities via Demand.
     * Demand object can be considered an "open" or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.
     *
     * **Note**: it is an "atomic" operation, ie. as soon as Subscription is placed, the Demand is published on the market.
     *
     * @param requestBody
     * @returns any Unexpected error.
     * @returns string Subscribed.
     * @throws ApiError
     */
    subscribeDemand(requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/demands',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
            },
        });
    }
    /**
     * UnsubscribeDemand - Stop subscription for previously published Demand.
     * Stop receiving Proposals.
     *
     * **Note**: this will terminate all pending `collectOffers` calls on this subscription. This implies, that client code should not `unsubscribeDemand` before it has received all expected/useful inputs from `collectOffers`.
     *
     * @param subscriptionId
     * @returns any Unexpected error.
     * @throws ApiError
     */
    unsubscribeDemand(subscriptionId) {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/demands/{subscriptionId}',
            path: {
                'subscriptionId': subscriptionId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                410: `Already unsubscribed.`,
            },
        });
    }
    /**
     * CollectOffers - Reads Market responses to published Demand.
     * This is a blocking operation. It will not return until there is at least one new event.
     * Returns Proposal related events:
     * * `ProposalEvent` - Indicates that there is new Offer Proposal for this Demand.
     * * `ProposalRejectedEvent` - Indicates that the Provider has rejected
     * our previous Proposal related to this Demand. This effectively ends a
     * Negotiation chain - it explicitly indicates that the sender will not
     * create another counter-Proposal.
     *
     * * `PropertyQueryEvent` - not supported yet.
     *
     * **Note**: When `collectOffers` is waiting, simultaneous call to `unsubscribeDemand` on the same `subscriptionId` should result in "Subscription does not exist" error returned from `collectOffers`.
     *
     * **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet.
     *
     * @param subscriptionId
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @returns any Proposal or Agreement event list.
     * @throws ApiError
     */
    collectOffers(subscriptionId, timeout = 5, maxEvents = 10) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/demands/{subscriptionId}/events',
            path: {
                'subscriptionId': subscriptionId,
            },
            query: {
                'timeout': timeout,
                'maxEvents': maxEvents,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
    /**
     * QueryReplyDemands - Handles dynamic property query.
     * Sends a response to a received property value query.
     *
     * The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.
     *
     * **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.
     *
     * **Note**: This method must be implemented for Market API Capability Level 2.
     *
     * @param subscriptionId
     * @param queryId
     * @param requestBody
     * @returns any Unexpected error.
     * @throws ApiError
     */
    queryReplyDemands(subscriptionId, queryId, requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/demands/{subscriptionId}/propertyQuery/{queryId}',
            path: {
                'subscriptionId': subscriptionId,
                'queryId': queryId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
    /**
     * GetProposalOffer - Fetches Proposal (Offer) with given id.
     * @param subscriptionId
     * @param proposalId
     * @returns any Proposal.
     * @throws ApiError
     */
    getProposalOffer(subscriptionId, proposalId) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/demands/{subscriptionId}/proposals/{proposalId}',
            path: {
                'subscriptionId': subscriptionId,
                'proposalId': proposalId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                410: `Proposal rejected.`,
            },
        });
    }
    /**
     * CounterProposalDemand - Responds with a bespoke Demand to received Offer.
     * Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to `Draft`. Returns created Proposal id.
     *
     * @param subscriptionId
     * @param proposalId
     * @param requestBody
     * @returns any Unexpected error.
     * @returns string Counter Proposal created.
     * @throws ApiError
     */
    counterProposalDemand(subscriptionId, proposalId, requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/demands/{subscriptionId}/proposals/{proposalId}',
            path: {
                'subscriptionId': subscriptionId,
                'proposalId': proposalId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                410: `Proposal rejected.`,
            },
        });
    }
    /**
     * RejectProposalOffer - Rejects Proposal (Offer).
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal.
     *
     * @param subscriptionId
     * @param proposalId
     * @param requestBody
     * @returns any Unexpected error.
     * @throws ApiError
     */
    rejectProposalOffer(subscriptionId, proposalId, requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/demands/{subscriptionId}/proposals/{proposalId}/reject',
            path: {
                'subscriptionId': subscriptionId,
                'proposalId': proposalId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                410: `Proposal already rejected.`,
            },
        });
    }
    /**
     * ListAgreements - Lists agreements with optional filters
     * List agreements.
     * Supported filters: * state * creation datetime * app session id
     * A well-formed call will result in a collection of objects with the following fields: * id * creationTs * approveTs * role
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param state State of an agreement
     * @param afterDate Apply only to records created later than the specified timestamp
     * @param beforeDate Apply only to records created before the specified timestamp
     * @returns any Result of listing agreements.
     * @throws ApiError
     */
    listAgreements(appSessionId, state, afterDate, beforeDate) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/agreements',
            query: {
                'appSessionId': appSessionId,
                'state': state,
                'afterDate': afterDate,
                'beforeDate': beforeDate,
            },
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
            },
        });
    }
    /**
     * CreateAgreement - Creates Agreement from selected Proposal.
     * Initiates the Agreement handshake phase.
     *
     * Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in `Proposal` state.
     *
     * The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.
     *
     * A successful call to `createAgreement` shall immediately be followed by a `confirmAgreement` and `waitForApproval` call in order to listen for responses from the Provider.
     *
     * **Note**: Moves given Proposal to `Approved` state.
     *
     * @param requestBody
     * @returns any Unexpected error.
     * @returns string Agreement created.
     * @throws ApiError
     */
    createAgreement(requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/agreements',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
                409: `Proposal not negotiated yet (in \`Initial\` state).`,
                410: `Proposal rejected or expired.`,
            },
        });
    }
    /**
     * GetAgreement - Fetches agreement with given agreement id.
     * @param agreementId
     * @returns any Agreement.
     * @throws ApiError
     */
    getAgreement(agreementId) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/agreements/{agreementId}',
            path: {
                'agreementId': agreementId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
    /**
     * CancelAgreement - Cancels Agreement.
     * It is only possible before Provider approved or rejected the Agreement, and before its Expiration.
     *
     * Causes:
     * - the awaiting `approveAgreement` on Provider side to return with `Cancelled` response.
     * - the awaiting `waitForApproval` local call to return with `Cancelled` response.
     *
     * @param agreementId
     * @param requestBody
     * @returns any Unexpected error.
     * @throws ApiError
     */
    cancelAgreement(agreementId, requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/agreements/{agreementId}/cancel',
            path: {
                'agreementId': agreementId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                410: `Agreement not in \`Proposal\` nor \`Pending\` state.`,
            },
        });
    }
    /**
     * ConfirmAgreement - Sends Agreement proposal to the Provider.
     * Signs self-created Agreement and sends it to the Provider.
     *
     * This call should immediately follow `createAgreement`.
     *
     * @param agreementId
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @returns any Unexpected error.
     * @throws ApiError
     */
    confirmAgreement(agreementId, appSessionId) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/agreements/{agreementId}/confirm',
            path: {
                'agreementId': agreementId,
            },
            query: {
                'appSessionId': appSessionId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                410: `Agreement not in \`Proposal\` state.`,
            },
        });
    }
    /**
     * WaitForApproval - Waits for Agreement approval by the Provider.
     * This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted or timed out, another `waitForApproval` call can be raised on the same Agreement Id.
     *
     * @param agreementId
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any Unexpected error.
     * @throws ApiError
     */
    waitForApproval(agreementId, timeout = 5) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/agreements/{agreementId}/wait',
            path: {
                'agreementId': agreementId,
            },
            query: {
                'timeout': timeout,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                408: `Agreement not approved within given timeout. Try again.`,
                409: `Agreement not confirmed yet by Requestor himself.`,
                410: `Agreement is not approved. This state is permanent.
                                            Attached \`ErrorMessage\` contains further details:
                                            - \`Rejected\` - Indicates that the Provider has called
                                            \`rejectAgreement\`, which effectively stops the Agreement handshake.
                                            The Requestor may attempt to return to the Negotiation phase by
                                            sending a new Proposal or to the Agreement phase by creating
                                            new Agreement.
                                            - \`Cancelled\` - Indicates that the Requestor himself has called
                                            \`cancelAgreement\`, which effectively stops the Agreement handshake.
                                            - \`Expired\` - Indicates that Agreement validity period elapsed and it
                                            was not approved, rejected nor cancelled.
                                            - \`Terminated\` - Indicates that Agreement is already terminated.
                                            `,
            },
        });
    }
    /**
     * CollectAgreementEvents - Collects events related to an Agreement.
     * This is a blocking operation. It will not return until there is at least one new event. All events are appearing on both sides equally.
     *
     * Returns Agreement related events:
     * * `AgreementApprovedEvent` - Indicates that the Agreement has been approved
     * by the Provider.
     * - The Provider is now ready to accept a request to start an Activity
     * as described in the negotiated agreement.
     * - The Providers’s corresponding `approveAgreement` call returns `Approved`
     * after this event is emitted.
     *
     * * `AgreementRejectedEvent` - Indicates that the Provider has called
     * `rejectAgreement`, which effectively stops the Agreement handshake.
     * The Requestor may attempt to return to the Negotiation phase by sending
     * a new Proposal.
     *
     * * `AgreementCancelledEvent` - Indicates that the Requestor has called
     * `cancelAgreement`, which effectively stops the Agreement handshake.
     *
     * * `AgreementTerminatedEvent` - Indicates that the Agreement has been
     * terminated by specified party (contains signature).
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @returns any Agreement-related event list.
     * @throws ApiError
     */
    collectAgreementEvents(timeout = 5, afterTimestamp, maxEvents = 10, appSessionId) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/agreementEvents',
            query: {
                'timeout': timeout,
                'afterTimestamp': afterTimestamp,
                'maxEvents': maxEvents,
                'appSessionId': appSessionId,
            },
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
    /**
     * TerminateAgreement - Terminates approved Agreement.
     * Method to finish/close the Agreement while in `Approved` state.
     *
     * The other party gets notified about calling party decision to terminate a "running" agreement.
     *
     * **Note**: Can be invoked at any time after Agreement was approved by both sides.
     *
     * **Note**: Financial and reputational consequences are not defined by this specification.
     *
     * @param agreementId
     * @param requestBody
     * @returns any Unexpected error.
     * @throws ApiError
     */
    terminateAgreement(agreementId, requestBody) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/agreements/{agreementId}/terminate',
            path: {
                'agreementId': agreementId,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
                409: `Agreement can not be terminated yet (is in \`Proposal\` or \`Pending\` state).`,
                410: `Agreement termination failed permanently.
                                            Attached \`ErrorMessage\` contains further details:
                                            - \`Rejected\` - Indicates that the Provider has rejected this Agreement.
                                            - \`Cancelled\` - Indicates the Requestor has called cancelled this Agreement.
                                            - \`Expired\` - Indicates that Agreement validity period elapsed and it was
                                            not approved, rejected nor cancelled.
                                            - \`Terminated\` - Indicates that Agreement is already terminated.
                                            `,
            },
        });
    }
    /**
     * Gets termination reason reported when terminateAgreement operation was called.
     * Method to get the reason for terminating the Agreement.
     *
     * @param agreementId
     * @returns any Agreement termination reason.
     * @throws ApiError
     */
    getTerminateAgreementReason(agreementId) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/agreements/{agreementId}/terminate/reason',
            path: {
                'agreementId': agreementId,
            },
            errors: {
                400: `(400) Bad request`,
                401: `(401) Authorization information is missing or invalid.`,
                404: `(404) The specified resource was not found.`,
            },
        });
    }
}
exports.RequestorService = RequestorService;
