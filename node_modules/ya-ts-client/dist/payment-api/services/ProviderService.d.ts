import type { CancelablePromise } from '../core/CancelablePromise';
import type { BaseHttpRequest } from '../core/BaseHttpRequest';
export declare class ProviderService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Issue a Debit Note.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    issueDebitNote(requestBody: {
        readonly debitNoteId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly previousDebitNoteId?: string;
        readonly timestamp: string;
        readonly agreementId: string;
        activityId: string;
        totalAmountDue: string;
        usageCounterVector?: Record<string, any>;
        paymentDueDate?: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }): CancelablePromise<{
        readonly debitNoteId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly previousDebitNoteId?: string;
        readonly timestamp: string;
        readonly agreementId: string;
        activityId: string;
        totalAmountDue: string;
        usageCounterVector?: Record<string, any>;
        paymentDueDate?: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getDebitNotes(afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        readonly debitNoteId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly previousDebitNoteId?: string;
        readonly timestamp: string;
        readonly agreementId: string;
        activityId: string;
        totalAmountDue: string;
        usageCounterVector?: Record<string, any>;
        paymentDueDate?: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>>;
    /**
     * Get Debit Note.
     * @param debitNoteId
     * @returns any OK
     * @throws ApiError
     */
    getDebitNote(debitNoteId: string): CancelablePromise<{
        readonly debitNoteId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly previousDebitNoteId?: string;
        readonly timestamp: string;
        readonly agreementId: string;
        activityId: string;
        totalAmountDue: string;
        usageCounterVector?: Record<string, any>;
        paymentDueDate?: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * @deprecated
     * Get Payments for Debit Note.
     * **WARNING:** Operation not implemented.
     *
     * @param debitNoteId
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getPaymentsForDebitNote(debitNoteId: string, afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>>;
    /**
     * Send Debit Note to Requestor.
     * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Debit Note or timeout has passed.
     *
     * @param debitNoteId
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    sendDebitNote(debitNoteId: string, timeout?: number): CancelablePromise<any>;
    /**
     * Cancel Debit Note.
     * **WARNING:** Operation not implemented.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Debit Note or timeout has passed. The Requestor may refuse to cancel the Debit Note if they have already accepted it.
     *
     * @param debitNoteId
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    cancelDebitNote(debitNoteId: string, timeout?: number): CancelablePromise<any>;
    /**
     * Get Debit Note events.
     * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the 'new' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.
     *
     * **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @returns any OK
     * @throws ApiError
     */
    getDebitNoteEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string): CancelablePromise<Array<{
        eventType: string;
        eventDate: string;
        debitNoteId: string;
    }>>;
    /**
     * Issue an Invoice.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    issueInvoice(requestBody: {
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }): CancelablePromise<{
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * Get Invoices known to this node (either issued by this Provider or received by this Requestor).
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getInvoices(afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>>;
    /**
     * Get Invoice.
     * @param invoiceId
     * @returns any OK
     * @throws ApiError
     */
    getInvoice(invoiceId: string): CancelablePromise<{
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * @deprecated
     * Get Payments for Invoice.
     * **WARNING:** Operation not implemented.
     *
     * @param invoiceId
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getPaymentsForInvoice(invoiceId: string, afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>>;
    /**
     * Send Invoice to Requestor.
     * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Invoice or timeout has passed.
     *
     * @param invoiceId
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    sendInvoice(invoiceId: string, timeout?: number): CancelablePromise<any>;
    /**
     * Cancel Invoice.
     * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Invoice or timeout has passed. The Requestor may refuse to cancel the Invoice if they have already accepted it.
     *
     * @param invoiceId
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    cancelInvoice(invoiceId: string, timeout?: number): CancelablePromise<any>;
    /**
     * Get Invoice events.
     * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the 'new' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.
     *
     * **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @returns any OK
     * @throws ApiError
     */
    getInvoiceEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string): CancelablePromise<Array<{
        eventType: string;
        eventDate: string;
        invoiceId: string;
    }>>;
    /**
     * Get available accounts for receiving payments.
     * @returns any OK
     * @throws ApiError
     */
    getProviderAccounts(): CancelablePromise<Array<{
        platform: string;
        address: string;
        driver: string;
        network: string;
        token: string;
        send: boolean;
        receive: boolean;
    }>>;
    /**
     * Get Payments.
     * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the 'new' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed. `network` and `driver` parameters can be used in order to filter payments.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param network Network identifier used for filtering payments made via the specified network
     * @param driver Driver identifier used for filtering payments made with the selected driver
     * @returns any OK
     * @throws ApiError
     */
    getPayments(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, network?: string, driver?: string): CancelablePromise<Array<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>>;
    /**
     * Get Payment.
     * @param paymentId
     * @returns any OK
     * @throws ApiError
     */
    getPayment(paymentId: string): CancelablePromise<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>;
    /**
     * Get status of the payment driver
     * This only relates to the erc20 driver, not erc20legacy. The returned list contains individual status properties, which can be used to identify problems like missing funds or misconfigured max fee per gas on a per-chain (network) basis.
     *
     * @param network Network identifier used for filtering payments made via the specified network
     * @param driver Driver identifier used for filtering payments made with the selected driver
     * @returns any OK
     * @throws ApiError
     */
    paymentsStatus(network?: string, driver?: string): CancelablePromise<Array<{
        /**
         * Determines what property this is. - InsufficientGas -- Driver cannot proceed due to missing gas. - InsufficientToken -- Driver cannot proceed due to missing tokens. - InvalidChainId -- A transaction can't be processed because its chain-id
         * isn't present in the configuration. This hints at a network being removed
         * from driver configuration after a transaction on this network has been
         * scheduled.
         * - CantSign -- Driver cannot sign transactions (locked wallet?). - RpcError -- All configured RPC endpoints are failing. - TxStuck -- Transaction was sent to blockchain successfully but cannot
         * proceed any further. Likely indicative of too low setting of max fee
         * per gas.
         *
         */
        kind: 'InsufficientGas' | 'InsufficientToken' | 'InvalidChainId' | 'CantSign' | 'TxStuck' | 'RpcError';
        /**
         * Payment driver to which this status property is applicable
         */
        driver: string;
        /**
         * Indicates which chain the problem occurs on. No statuses other than CantSign necessarily imply issues on other chains than the one the status property originates from.
         * Present for all status properties other than InvalidChainId.
         *
         */
        network?: string;
        /**
         * Estimate total required gas to complete all outstanding transactions.
         * Only present for InsufficientGas
         *
         */
        neededGasEst?: string;
        /**
         * Estimate total required token to complete all outstanding transactions.
         * Only present for InsufficientToken
         *
         */
        neededTokenEst?: string;
        /**
         * Relates the status event to a specific blockchain address.
         * Only present for CantSign, InsufficientGas and InsufficientToken.
         *
         */
        address?: string;
        /**
         * Chain-id that the error relates to.
         * Only present for InvalidChainId.
         *
         */
        chainId?: number;
    }>>;
}
