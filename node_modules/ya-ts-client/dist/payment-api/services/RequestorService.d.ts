import type { CancelablePromise } from '../core/CancelablePromise';
import type { BaseHttpRequest } from '../core/BaseHttpRequest';
export declare class RequestorService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getDebitNotes(afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        readonly debitNoteId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly previousDebitNoteId?: string;
        readonly timestamp: string;
        readonly agreementId: string;
        activityId: string;
        totalAmountDue: string;
        usageCounterVector?: Record<string, any>;
        paymentDueDate?: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>>;
    /**
     * Get Debit Note.
     * @param debitNoteId
     * @returns any OK
     * @throws ApiError
     */
    getDebitNote(debitNoteId: string): CancelablePromise<{
        readonly debitNoteId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly previousDebitNoteId?: string;
        readonly timestamp: string;
        readonly agreementId: string;
        activityId: string;
        totalAmountDue: string;
        usageCounterVector?: Record<string, any>;
        paymentDueDate?: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * @deprecated
     * Get Payments for Debit Note.
     * **WARNING:** Operation not implemented.
     *
     * @param debitNoteId
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getPaymentsForDebitNote(debitNoteId: string, afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>>;
    /**
     * Get Debit Note events.
     * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the 'new' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.
     *
     * **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @returns any OK
     * @throws ApiError
     */
    getDebitNoteEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string): CancelablePromise<Array<{
        eventType: string;
        eventDate: string;
        debitNoteId: string;
    }>>;
    /**
     * Issue an Invoice.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    issueInvoice(requestBody: {
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }): CancelablePromise<{
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * Get Invoices known to this node (either issued by this Provider or received by this Requestor).
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getInvoices(afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>>;
    /**
     * Get Invoice.
     * @param invoiceId
     * @returns any OK
     * @throws ApiError
     */
    getInvoice(invoiceId: string): CancelablePromise<{
        readonly invoiceId: string;
        readonly issuerId: string;
        readonly recipientId: string;
        readonly payeeAddr: string;
        readonly payerAddr: string;
        readonly paymentPlatform: string;
        readonly timestamp: string;
        agreementId: string;
        activityIds?: Array<string>;
        amount: string;
        paymentDueDate: string;
        /**
         * Accepted status indicates that the Requestor confirms the Amount/Total Amount Due on the Invoice/Debit Note, respectively. The Payment API Implementation is expected to proceed with the orchestration of the payment. Internals of the payment processing (e.g. payment processing internal states) are specific to the selected Payment Platform, and must be indicated as an attribute of the Accepted status. However, as they are specific - they shall not be standardized by the Payment API.
         *
         * A Rejected Invoice/Debit Note can subsequently be Accepted.
         *
         * An Accepted Invoice/Debit Note cannot be subsequently Rejected.
         *
         * There is a difference between Paid and Settled - depending on a Payment Platform. Paid indicates that the Requestor has ordered Payments of Total Amount Due as indicated by received/accepted Debit Notes/Invoice. Settled indicates that the Provider has reliably received the Payments.
         *
         * **WARNING:** 'Paid' status currently not implemented.
         *
         */
        readonly status: 'ISSUED' | 'RECEIVED' | 'ACCEPTED' | 'REJECTED' | 'FAILED' | 'SETTLED' | 'CANCELLED';
    }>;
    /**
     * @deprecated
     * Get Payments for Invoice.
     * **WARNING:** Operation not implemented.
     *
     * @param invoiceId
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    getPaymentsForInvoice(invoiceId: string, afterTimestamp?: string, maxItems?: number): CancelablePromise<Array<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>>;
    /**
     * Get Invoice events.
     * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the 'new' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.
     *
     * **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @returns any OK
     * @throws ApiError
     */
    getInvoiceEvents(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string): CancelablePromise<Array<{
        eventType: string;
        eventDate: string;
        invoiceId: string;
    }>>;
    /**
     * Accept received Debit Note.
     * Send Debit Note Accepted message to Debit Note Issuer. If Debit Note is binding (i.e. has non-null payment due date) trigger payment orchestration for this Debit Note using specified Allocation.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged accepting the Invoice or timeout has passed.
     *
     * **NOTE:** An Accepted Debit Note cannot be Rejected later.
     *
     * @param debitNoteId
     * @param requestBody
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    acceptDebitNote(debitNoteId: string, requestBody: {
        totalAmountAccepted: string;
        allocationId: string;
        autoAcceptTo?: string;
    }, timeout?: number): CancelablePromise<any>;
    /**
     * Reject received Debit Note.
     * **WARNING:** Operation not implemented.
     *
     * Send Debit Note Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept the Debit Note (for some reason).
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.
     *
     * **NOTE:** A Rejected Debit Note can be Accepted subsequently (e.g. as a result of some arbitrage).
     *
     * @param debitNoteId
     * @param requestBody
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    rejectDebitNote(debitNoteId: string, requestBody: {
        /**
         * Possible reasons to reject a Debit Note or Invoice.
         */
        rejectionReason: 'UNSOLICITED_SERVICE' | 'BAD_SERVICE' | 'INCORRECT_AMOUNT';
        totalAmountAccepted: string;
        message?: string;
    }, timeout?: number): CancelablePromise<any>;
    /**
     * Accept received Invoice.
     * Send Invoice Accepted message to Invoice Issuer. Trigger payment orchestration for this Invoice using specified Allocation.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.
     *
     * **NOTE:** An Accepted Invoice cannot be Rejected later.
     *
     * @param invoiceId
     * @param requestBody
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    acceptInvoice(invoiceId: string, requestBody: {
        totalAmountAccepted: string;
        allocationId: string;
    }, timeout?: number): CancelablePromise<any>;
    /**
     * Reject received Invoice.
     * **WARNING:** Operation not implemented.
     *
     * Send Invoice Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept Invoice (for some reason).
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.
     *
     * **NOTE:** A Rejected Invoice can be Accepted subsequently (e.g. as a result of some arbitrage).
     *
     * @param invoiceId
     * @param requestBody
     * @param timeout Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party's response indefinitely)
     *
     * @returns any OK
     * @throws ApiError
     */
    rejectInvoice(invoiceId: string, requestBody: {
        /**
         * Possible reasons to reject a Debit Note or Invoice.
         */
        rejectionReason: 'UNSOLICITED_SERVICE' | 'BAD_SERVICE' | 'INCORRECT_AMOUNT';
        totalAmountAccepted: string;
        message?: string;
    }, timeout?: number): CancelablePromise<any>;
    /**
     * Create Allocation.
     * Allocate funds to make sure they are not spent elsewhere.
     * @param requestBody
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxItems Maximum number of items that server should return at once.
     *
     * @returns any OK
     * @throws ApiError
     */
    createAllocation(requestBody: {
        readonly allocationId: string;
        address?: string;
        paymentPlatform?: string;
        totalAmount: string;
        readonly spentAmount: string;
        readonly remainingAmount: string;
        readonly timestamp: string;
        timeout?: string;
        makeDeposit?: boolean;
        /**
         * in seconds, the time by which the allocation timeout is extended after it is last used.
         *
         */
        extendTimeout?: number;
        deposit?: {
            id: string;
            contract: string;
            validate?: Record<string, any>;
        };
    }, afterTimestamp?: string, maxItems?: number): CancelablePromise<{
        readonly allocationId: string;
        address?: string;
        paymentPlatform?: string;
        totalAmount: string;
        readonly spentAmount: string;
        readonly remainingAmount: string;
        readonly timestamp: string;
        timeout?: string;
        makeDeposit?: boolean;
        /**
         * in seconds, the time by which the allocation timeout is extended after it is last used.
         *
         */
        extendTimeout?: number;
        deposit?: {
            id: string;
            contract: string;
            validate?: Record<string, any>;
        };
    }>;
    /**
     * Get Allocations.
     * @returns any OK
     * @throws ApiError
     */
    getAllocations(): CancelablePromise<Array<{
        readonly allocationId: string;
        address?: string;
        paymentPlatform?: string;
        totalAmount: string;
        readonly spentAmount: string;
        readonly remainingAmount: string;
        readonly timestamp: string;
        timeout?: string;
        makeDeposit?: boolean;
        /**
         * in seconds, the time by which the allocation timeout is extended after it is last used.
         *
         */
        extendTimeout?: number;
        deposit?: {
            id: string;
            contract: string;
            validate?: Record<string, any>;
        };
    }>>;
    /**
     * Get Allocation.
     * @param allocationId
     * @returns any OK
     * @throws ApiError
     */
    getAllocation(allocationId: string): CancelablePromise<{
        readonly allocationId: string;
        address?: string;
        paymentPlatform?: string;
        totalAmount: string;
        readonly spentAmount: string;
        readonly remainingAmount: string;
        readonly timestamp: string;
        timeout?: string;
        makeDeposit?: boolean;
        /**
         * in seconds, the time by which the allocation timeout is extended after it is last used.
         *
         */
        extendTimeout?: number;
        deposit?: {
            id: string;
            contract: string;
            validate?: Record<string, any>;
        };
    }>;
    /**
     * Amend Allocation.
     * @param allocationId
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    amendAllocation(allocationId: string, requestBody: {
        totalAmount?: string;
        timeout?: string;
        deposit?: {
            validate?: Record<string, any>;
        };
    }): CancelablePromise<{
        readonly allocationId: string;
        address?: string;
        paymentPlatform?: string;
        totalAmount: string;
        readonly spentAmount: string;
        readonly remainingAmount: string;
        readonly timestamp: string;
        timeout?: string;
        makeDeposit?: boolean;
        /**
         * in seconds, the time by which the allocation timeout is extended after it is last used.
         *
         */
        extendTimeout?: number;
        deposit?: {
            id: string;
            contract: string;
            validate?: Record<string, any>;
        };
    }>;
    /**
     * Release Allocation.
     * The Allocation of amount is released. Note that this operation releases currently allocated amount (which may have been reduced by subsequent Invoice Payments).
     *
     * **WARNING:** Deposits not implemented.
     *
     * If the Allocation was connected with a Deposit the release amount from Deposit shall be marked as pending to be paid back to Requestor - and eventually will be paid back, unless a subsequent Allocation with Deposit is made. The Payment Platform implementations may optimize unnecessary fund transfers (i.e. will not pay back the Deposit if released funds can be assigned to a new Allocation with Deposit).
     *
     * @param allocationId
     * @returns any OK
     * @throws ApiError
     */
    releaseAllocation(allocationId: string): CancelablePromise<any>;
    /**
     * Get Payments.
     * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the 'new' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed. `network` and `driver` parameters can be used in order to filter payments.
     *
     * @param timeout Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (`0.0` means it should return immediately if there are no events)
     *
     * @param afterTimestamp Apply only to records created later than the specified timestamp
     * @param maxEvents Maximum number of events that server should return at once.
     *
     * @param appSessionId A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param network Network identifier used for filtering payments made via the specified network
     * @param driver Driver identifier used for filtering payments made with the selected driver
     * @returns any OK
     * @throws ApiError
     */
    getPayments(timeout?: number, afterTimestamp?: string, maxEvents?: number, appSessionId?: string, network?: string, driver?: string): CancelablePromise<Array<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>>;
    /**
     * Get Payment.
     * @param paymentId
     * @returns any OK
     * @throws ApiError
     */
    getPayment(paymentId: string): CancelablePromise<{
        paymentId: string;
        payerId: string;
        payeeId: string;
        payerAddr: string;
        payeeAddr: string;
        paymentPlatform: string;
        amount: string;
        timestamp: string;
        agreementPayments: Array<{
            agreementId: string;
            amount: string;
            allocationId?: string;
        }>;
        activityPayments: Array<{
            activityId: string;
            amount: string;
            allocationId?: string;
        }>;
        details: string;
    }>;
    /**
     * Get status of the payment driver
     * This only relates to the erc20 driver, not erc20legacy. The returned list contains individual status properties, which can be used to identify problems like missing funds or misconfigured max fee per gas on a per-chain (network) basis.
     *
     * @param network Network identifier used for filtering payments made via the specified network
     * @param driver Driver identifier used for filtering payments made with the selected driver
     * @returns any OK
     * @throws ApiError
     */
    paymentsStatus(network?: string, driver?: string): CancelablePromise<Array<{
        /**
         * Determines what property this is. - InsufficientGas -- Driver cannot proceed due to missing gas. - InsufficientToken -- Driver cannot proceed due to missing tokens. - InvalidChainId -- A transaction can't be processed because its chain-id
         * isn't present in the configuration. This hints at a network being removed
         * from driver configuration after a transaction on this network has been
         * scheduled.
         * - CantSign -- Driver cannot sign transactions (locked wallet?). - RpcError -- All configured RPC endpoints are failing. - TxStuck -- Transaction was sent to blockchain successfully but cannot
         * proceed any further. Likely indicative of too low setting of max fee
         * per gas.
         *
         */
        kind: 'InsufficientGas' | 'InsufficientToken' | 'InvalidChainId' | 'CantSign' | 'TxStuck' | 'RpcError';
        /**
         * Payment driver to which this status property is applicable
         */
        driver: string;
        /**
         * Indicates which chain the problem occurs on. No statuses other than CantSign necessarily imply issues on other chains than the one the status property originates from.
         * Present for all status properties other than InvalidChainId.
         *
         */
        network?: string;
        /**
         * Estimate total required gas to complete all outstanding transactions.
         * Only present for InsufficientGas
         *
         */
        neededGasEst?: string;
        /**
         * Estimate total required token to complete all outstanding transactions.
         * Only present for InsufficientToken
         *
         */
        neededTokenEst?: string;
        /**
         * Relates the status event to a specific blockchain address.
         * Only present for CantSign, InsufficientGas and InsufficientToken.
         *
         */
        address?: string;
        /**
         * Chain-id that the error relates to.
         * Only present for InvalidChainId.
         *
         */
        chainId?: number;
    }>>;
    /**
     * Get available accounts for sending payments.
     * @returns any OK
     * @throws ApiError
     */
    getRequestorAccounts(): CancelablePromise<Array<{
        platform: string;
        address: string;
        driver: string;
        network: string;
        token: string;
        send: boolean;
        receive: boolean;
    }>>;
    /**
     * Obtain Demand elements specific to the given allocations, to be appended to a market Demand.
     * Generate payment-related properties and constraints to be added to a demand published on the marketplace. As a parameter it accepts a list of IDs of allocations to be used to pay for invoices resulting from the decorated demand.
     *
     * @param allocationIds
     * @returns any OK
     * @throws ApiError
     */
    getDemandDecorations(allocationIds: Array<string>): CancelablePromise<{
        properties: Array<{
            key: string;
            value: string;
        }>;
        constraints: Array<string>;
    }>;
}
